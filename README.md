#**Sniper Kill**

Windows Form Project by: Alek Petreski, Andreja Jovanovski and Nikola Kirovski

##1. Опис на апликацијата
**Sniper Kill** претставува едноставна имплементација на класичната игра [Sniper](http://armorgames.com/category/sniper-games). Целта на оваа игра е да се отстранат одреден број на непријатели за што помалку време. Победник е оној што ќе успее да ги уништи сите непријатели во најмал временски период.

##2. Упатство за користење
При стартување на апликацијата се отвара почетната форма која претставува мени на играта. Во оваа форма има пет опции:
* **Start game** - почеток на нова игра
* **Options** - подесување на нишанот
* **Highscores** - преглед на најдобрите резултати
* **How to play** - преглед на контролите за играње
* **Credits** - преглед на креаторите на играта
* **Exit** - излез од играта

Исто така, во оваа форма корисникот може да одбере различно ниво на тежина:
* Easy
* Medium
* Hard

###2.1 Start game
Со притискање на копчето **Start game** се отвара нова форма во која започнува играта. Корисникот со движење на глувчето треба да ги
лоцира непријателите и да ги отстрани со притискање на левиот клик. Во зависност од нивото на тежина непријателите се појавуваат на
различни временски интервали. Нивото завршува кога ќе се отстранат сите осум непријатели, а играта завршува кога ќе се пројдат сите пет нивоа.

###2.2 Options
Со притискање на копчето **Options** се отвара нова форма во која корисникот може да ја избере бојата, дебелината, големината или стилот на нишанот. Доколку корисникот не ги подеси овие параметри нишанот има:
* црвена боја
* дебелина 2px
* радиус 240px
* испрекината линија

###2.3 Highscores
Со притискање на копчето **Highscores** се отвара нова форма во која корисникот може да ги разгледа десетте најдобри резултати сортирани според времето и нивото на тежина. Пресметувањето на поените се врши на три начини:

1. Доколку играчот погоди противник, во зависност од нивото на тежина (easy=1, medium=2, hard=3), се добиваат 10*(тежината) поени.
2. Доколку играчот промаши противник се одземаат 10 поени.
3. Доколку играчот го пројде нивото, се добиваат 2*(преостанато време) поени.

Поените на сите играчи се зачувани во датотеката scores.txt која при секое иницијализирање на формата Highscores се исчитува и ги прикажува најдобрите 10 резултати.
Креирањето на оваа датотека се извршува при иницијализација на почетната форма и потоа само се исчитува од неа.

###2.4 How to play
Со притискање на копчето **How to play** се отвара нова форма во која корисникот може да ги види контролите за играње. Контролите се 
едноставни:
* **left click** - пукање
* **z** - тргни нишан
* **x** - намести нишан

###2.5 Credits
Со притискање на копчето **Credits** се отвара нова форма во која корисникот може да ги види креаторите на оваа игра.

###2.6 Exit
Со притискање на копчето **Exit** се отвара дијалог прозорец во кој корисникот има можност да избере дали навистина сака да ја исклучи
играта или да продолжи со играње.

##3. Претставување на проблемот

###3.1 Податочни структури
За имплементација на оваа игра потребни ни беа неколку класи:
* **Crosshair** - класа во која се чуваат податоци за нишанот
* **CustomFont** - static класа во која се иницијализира фонтот
* **Enemy** - класа во која се чуваат координатите и големината на противниците
* **Map** - класа во која се избира соодветната мапа со соодветните противници
* **Player** - класа во која се чуваат информации за моменталниот играч
* **Score** - класа во која се пресметува резултатот

###3.2 Исцртување на нишанот
Во класата **Crosshair** се чуваат следниве податоци за нишанот:
```c#
public int Size { get; set; }
public string Style { get; set; }
public int Thickness { get; set; }
public Color Color { get; set; }
public Point currentPoint { get; set; }
```
При секое движење на глувчето во формата ```FormMap``` се земаат моменталните координати од настанот ```pictureBoxMap_MouseMove``` и се доделуваат на точката currentPoint. Притоа со ```Draw(Graphics g)``` методот, кој се повикува во ```pictureBoxMap_Paint```, се прецртува нишанот на новите координати.  
```c#
public void Draw(Graphics g)
{
    Pen solidPen = new Pen(Color, 10);
    Pen dashedPen = new Pen(Color, Thickness);
    dashedPen.DashStyle = setDashStyle();
    SolidBrush brush = new SolidBrush(Color.Black);
            
    g.DrawLine(dashedPen, currentPoint.X, currentPoint.Y - (Size / 2), currentPoint.X, currentPoint.Y + (Size / 2));
    g.DrawLine(dashedPen, currentPoint.X - (Size / 2), currentPoint.Y, currentPoint.X + (Size / 2), currentPoint.Y);
    g.DrawEllipse(solidPen, currentPoint.X - (Size / 2), currentPoint.Y - (Size / 2), Size, Size);

    GraphicsPath path = new GraphicsPath();
    path.AddEllipse(currentPoint.X - (Size / 2), currentPoint.Y - (Size / 2), Size, Size);
    Region region = new Region();
    region.Exclude(path);
    g.FillRegion(brush, region);
}
```

###3.3 Избирање на противник и цртање
Во класата **Enemy** се извршуваат сите операции поврзани со појавувањето и бришењето на противниците. Во оваа класа користиме структура ```Dictonary<Point, int>``` во која ги чуваме координатите на секој противник и неговата големина. Во зависност од нивото, оваа структура се иницијализира со различни вредности. Исто така, користиме структура ```List<Image>``` во која ги чуваме сликите од противниците.
Во самата класа имаме функција ```selectEnemy()``` која на случаен начин одбира позиција на која што ќе се појави противникот. Дополнително со функцијата ```selectImage()``` случајно бираме слика за противникот.
Пресметките каде да се исцрта противникот се извршуваат во функцијата ```setEnemyPoint(Point drawPoint)```, а во функцијата ```Draw(Graphics g)``` се врши исцртувањето на противникот на мапата.
```c#
public void selectEnemy()
{
    int i = random.Next(positions.Count);
    Size = positions.Values.ElementAt(i);
    Radius = Size / 4;
    drawPoint = positions.Keys.ElementAt(i);

    enemyPosition = setEnemyPoint(drawPoint);
}

public Image selectImage()
{
    int i = random.Next(images.Count);
    return images[i];
}

public Point setEnemyPoint(Point drawPoint)
{
    return new Point((drawPoint.X / 2) + Radius, (drawPoint.Y / 2) + Radius);
}

public void Draw(Graphics g)
{
    selectEnemy();
    g.DrawImage(selectImage(), drawPoint.X, drawPoint.Y, Size, Size);
}
```

###3.4 Алгоритми и пресметки
